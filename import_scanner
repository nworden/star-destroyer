#!/usr/bin/env python

import importlib
import os
import sys
from tokenize import COMMENT, DOT, ENCODING, ENDMARKER, INDENT, DEDENT, NAME, NEWLINE, NL, OP
from tokenize import tokenize, untokenize
import tokutils

module_alls = {}

def get_all_list(modpath, package=None):
    """Gets the list of all names that are *-exported from a module."""
    if not modpath in module_alls:
        if package:
            importlib.import_module(package)
        module = importlib.import_module(modpath, package)
        module_alls[modpath] = getattr(module, '__all__', [
            name for name in dir(module) if not name.startswith('_')])
    return module_alls[modpath]

def destroy_stars(modpath, filename, importers, tokens):
    package = modpath.rsplit('.', 1)[0] if '.' in modpath else None

    # Edit the list of tokens to produce a new list in edited_tokens.
    edited_tokens = tokutils.Emitter()

    stmt = []
    for token in tokens:
        stmt.append(token)

        # Process the tokens one statement at a time.
        if token.type in {ENCODING, NL, NEWLINE, ENDMARKER}:
            strings = [t.string for t in stmt]

            # If it's a from ... import '*' statement, we want to edit it.
            if (strings and strings[0] == 'from' and
                'import' in strings and '*' in strings):
                i = strings.index('import')
                imported = ''.join(strings[1:i])
                edited_tokens.add_tokens(stmt[:i + 1])
                edited_tokens.add_text(
                    ', '.join(sorted(get_all_list(imported, package))), 1)
                edited_tokens.add_newline()
            else:
                edited_tokens.add_tokens(stmt)
            stmt = []

    # Write out the edited file.
    data = untokenize(edited_tokens)
    with open(path, 'wb') as file:
        file.write(data)

def get_module_files(roots):
    """Given a list of (root_path, root_package) pairs, scans for .py files
    under each root path and generates a (dotted_path, filename) pair for each
    Python module found, skipping shadowed packages and modules.  dotted_path
    is prefixed with root_package; root_package should be '' in most cases."""
    seen = {}
    for root, root_package in roots:
        root_parts = os.path.abspath(root).split('/')
        root_package = root_package and root_package.split('.') or []
        for path, dirs, files in os.walk(root):
            path_parts = os.path.abspath(path).split('/')
            package = '.'.join(root_package + path_parts[len(root_parts):])
            if path == root or '__init__.py' in files and package not in seen:
                for file in files:
                    if file.endswith('.py'):
                        name = file[:-3]
                        module = (package and package + '.') + name
                        if name == '__init__' and package:
                            module = package
                        if module not in seen:
                            seen.add(module)
                            yield module, os.path.join(path, file)


# Every module imports some names, uses some names, and exports some names.
#
# Each import copies a name in some other module to become a name in the
# current scope; the "origin" of the import is the location of the original
# name in package.module.name form.
#
# Each statement uses some of the names that are in scope; associated with
# each name is the set of all possible external origins for that name.
# Sometimes this set is empty (e.g. for the name 'x' just after 'x = 3');
# sometimes it's a set of one possibility (e.g. for the name 'foo' immediately
# after 'import foo'); and sometimes it contains multiple possibilities (e.g.
# for the name 'x' after 'import foo as x; if y: import bar as x').
#
# Exports only matter at the end of the module; we determine these by
# actually importing the module and looking for all the names (or __all__).


class ScopeStack:
    """A stack of scopes; each scope is a dictionary of variable names."""

    def __init__(self):
        self.dicts = [{}]

    def __setitem__(self, key, value):
        self.dicts[-1][key] = value

    def __getitem__(self, key):
        for d in reversed(self.dicts):
            if key in d:
                return d[key]
        raise KeyError(key)

    def push(self):
        self.dicts.append({})

    def pop(self):
        self.dicts.pop()


def scan_module(modpath, ast):
    """Scans a module's AST, returning a set of all origins used in the module.
    During the scan, scope_stack maps each name in scope to its set of possible
    origins; whenever a name is used, its origins are added to the set of all
    origins used by the module."""



class ReferenceGraph:
    def __init__(self):
        self.references = {}  # maps modules to sets of referenced symbols
        self.star_exporters = set()  # modules that might export anything

    def scan_modules(self, module_files):
        scanned = {}
        sys.stderr.write('Scanning %d modules' % len(module_files))
        for module, path in sorted(module_files.keys()):
            sys.stderr.write('.')
            sys.stderr.flush()
            self.scan_module(module, tokutils.tokenize_file(path))
        sys.stderr.write('\n')

    def scan_module(self, module, tokens):
        """Scans the tokens for a module to determine which names it uses.
        The end result is a set of source definition sites that are used
        in this module (each definition site in package.module.name form).
        During the scan, scope_stack tracks what has been imported by mapping
        each name to the set of possible source definitions that it might
        refer to (there can be multiple possibilities due to if-statements);
        when a name is used it gets added to definitions_used."""

        scope_stack = ScopeStack()  # {name: set of definitions it could be}
        scope_levels = [0]  # indentation level of each scope in the stack
        level = 0  # current indentation level
        definitions_used = set()  # set of definitions used in this module

        # Assumption: Names become bound to modules only by import statements.
        # Upheld if modules (as opposed to names within them) are never
        # referenced after import:
        #   - By name
        #   - Via the __dict__ attribute on a module.
        #   - Via dictionary views on globals and locals (globals(), locals()
        #     func_globals, ...)
        #   - Via sys.modules
        #
        # Assumption: Values defined in imported modules are referenced only
        # as "module.name".  Upheld if:
        #   - getattr() is never called on a module.
        #   - The __dict__ attribute is never referenced on a module.
        # Both are true if modules are never referenced after import.
        #
        # Assumption: All names exported by a module are defined within the
        # module itself, or imported into the module by import statements in
        # the module itself.  Upheld if:
        #   - References to modules or names within modules never appear on
        #     the left side of an assignment.
        #   - setattr() is never called on a module.
        #   - The __dict__ attribute is never referenced on a module.
        # Last two are true if modules are never referenced after import.
        #
        # Assumption: There aren't circular imports set up in such a way that
        # the values of module variables depend on import order.

        for stmt in get_statements(tokens):
            # Track indentation level so know when to pop scopes.
            indentation = (len(t for t in stmt if t.type == INDENT) -
                           len(t for t in stmt if t.type == DEDENT))
            level += indentation
            while level < scope_levels[-1]:
                scope_stack.pop()

            # Words are non-whitespace tokens, except that a contiguous
            # sequences of dotted names is treated as one word.
            words = ' '.join(t.string for t in stmt
                      ).replace(' . ', '.').split()

            if words[0] in {'class', 'def'}:
                scope_stack.push()

            if words[0] == 'from':
                exporter = words[1]




def get_statements(tokens):
    """Groups a list of tokens into lists for each statement."""
    stmt = []
    for token in tokens:
        stmt.append(token)
        if token.type in {ENCODING, NL, NEWLINE, ENDMARKER}:
            yield stmt
            stmt = []
    if stmt:
        yield stmt

def get_imported_modules(module_tokens):
    """Gets a dictionary mapping modules to the modules that import them."""
    importers = {}

    for module, tokens in sorted(module_tokens.items()):
        print(module)
        stmt = []
        for token in tokens:
            stmt.append(token)

            # Process the tokens one statement at a time.
            if token.type in {ENCODING, NL, NEWLINE, ENDMARKER}:
                # Get the words, ignoring indentation.
                words = ' '.join(t.string for t in stmt).split()

                if words[:1] == ['from']:
                    i = words.index('import')
                    imported = ''.join(words[1:i])
                    importers.setdefault(imported, set()).add(module)

                elif words[:1] == ['import']:
                    imps = ' '.join(words).split(',')
                    for imp in imps:
                        words = imp.split(' ')
                        if 'as' in words:
                            words[words.index('as'):] = []
                        imported = ''.join(words)
                        importers.setdefault(imported, set()).add(module)
                stmt = []
    return importers

def main(args):
    module_files = get_module_files([
        (arg.split(':')[0], arg.split(':')[-1] if ':' in arg else '')
        for arg in args])
    module_tokens = get_module_tokens(module_files)
    importers = get_imported_modules(module_tokens)
    importers = {module: importers[module]
                 for module in importers
                 if module in module_files}
    print('%d modules, %d imported' % (len(module_files), len(importers)))
    import pprint
    pprint.pprint(importers)

if len(sys.argv) > 1:
    main(sys.argv[1:])
else:
    print('Usage: %s <filename.py>...' % sys.argv[0])
    print('Replaces * with a list of names, in from ... import *.')
